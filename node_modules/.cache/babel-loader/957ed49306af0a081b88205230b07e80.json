{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('../GetIntrinsic');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $SyntaxError = GetIntrinsic('%SyntaxError%');\n\nvar has = require('has');\n\nvar predicates = {\n  // https://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type\n  'Property Descriptor': function isPropertyDescriptor(ES, Desc) {\n    if (ES.Type(Desc) !== 'Object') {\n      return false;\n    }\n\n    var allowed = {\n      '[[Configurable]]': true,\n      '[[Enumerable]]': true,\n      '[[Get]]': true,\n      '[[Set]]': true,\n      '[[Value]]': true,\n      '[[Writable]]': true\n    };\n\n    for (var key in Desc) {\n      // eslint-disable-line\n      if (has(Desc, key) && !allowed[key]) {\n        return false;\n      }\n    }\n\n    var isData = has(Desc, '[[Value]]');\n    var IsAccessor = has(Desc, '[[Get]]') || has(Desc, '[[Set]]');\n\n    if (isData && IsAccessor) {\n      throw new $TypeError('Property Descriptors may not be both accessor and data descriptors');\n    }\n\n    return true;\n  }\n};\n\nmodule.exports = function assertRecord(ES, recordType, argumentName, value) {\n  var predicate = predicates[recordType];\n\n  if (typeof predicate !== 'function') {\n    throw new $SyntaxError('unknown record type: ' + recordType);\n  }\n\n  if (!predicate(ES, value)) {\n    throw new $TypeError(argumentName + ' must be a ' + recordType);\n  }\n};","map":{"version":3,"sources":["C:/Users/gordon/Desktop/testRecrutement/node_modules/es-abstract/helpers/assertRecord.js"],"names":["GetIntrinsic","require","$TypeError","$SyntaxError","has","predicates","isPropertyDescriptor","ES","Desc","Type","allowed","key","isData","IsAccessor","module","exports","assertRecord","recordType","argumentName","value","predicate"],"mappings":"AAAA;;AAEA,IAAIA,YAAY,GAAGC,OAAO,CAAC,iBAAD,CAA1B;;AAEA,IAAIC,UAAU,GAAGF,YAAY,CAAC,aAAD,CAA7B;AACA,IAAIG,YAAY,GAAGH,YAAY,CAAC,eAAD,CAA/B;;AAEA,IAAII,GAAG,GAAGH,OAAO,CAAC,KAAD,CAAjB;;AAEA,IAAII,UAAU,GAAG;AAChB;AACA,yBAAuB,SAASC,oBAAT,CAA8BC,EAA9B,EAAkCC,IAAlC,EAAwC;AAC9D,QAAID,EAAE,CAACE,IAAH,CAAQD,IAAR,MAAkB,QAAtB,EAAgC;AAC/B,aAAO,KAAP;AACA;;AACD,QAAIE,OAAO,GAAG;AACb,0BAAoB,IADP;AAEb,wBAAkB,IAFL;AAGb,iBAAW,IAHE;AAIb,iBAAW,IAJE;AAKb,mBAAa,IALA;AAMb,sBAAgB;AANH,KAAd;;AASA,SAAK,IAAIC,GAAT,IAAgBH,IAAhB,EAAsB;AAAE;AACvB,UAAIJ,GAAG,CAACI,IAAD,EAAOG,GAAP,CAAH,IAAkB,CAACD,OAAO,CAACC,GAAD,CAA9B,EAAqC;AACpC,eAAO,KAAP;AACA;AACD;;AAED,QAAIC,MAAM,GAAGR,GAAG,CAACI,IAAD,EAAO,WAAP,CAAhB;AACA,QAAIK,UAAU,GAAGT,GAAG,CAACI,IAAD,EAAO,SAAP,CAAH,IAAwBJ,GAAG,CAACI,IAAD,EAAO,SAAP,CAA5C;;AACA,QAAII,MAAM,IAAIC,UAAd,EAA0B;AACzB,YAAM,IAAIX,UAAJ,CAAe,oEAAf,CAAN;AACA;;AACD,WAAO,IAAP;AACA;AA3Be,CAAjB;;AA8BAY,MAAM,CAACC,OAAP,GAAiB,SAASC,YAAT,CAAsBT,EAAtB,EAA0BU,UAA1B,EAAsCC,YAAtC,EAAoDC,KAApD,EAA2D;AAC3E,MAAIC,SAAS,GAAGf,UAAU,CAACY,UAAD,CAA1B;;AACA,MAAI,OAAOG,SAAP,KAAqB,UAAzB,EAAqC;AACpC,UAAM,IAAIjB,YAAJ,CAAiB,0BAA0Bc,UAA3C,CAAN;AACA;;AACD,MAAI,CAACG,SAAS,CAACb,EAAD,EAAKY,KAAL,CAAd,EAA2B;AAC1B,UAAM,IAAIjB,UAAJ,CAAegB,YAAY,GAAG,aAAf,GAA+BD,UAA9C,CAAN;AACA;AACD,CARD","sourcesContent":["'use strict';\n\nvar GetIntrinsic = require('../GetIntrinsic');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $SyntaxError = GetIntrinsic('%SyntaxError%');\n\nvar has = require('has');\n\nvar predicates = {\n\t// https://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type\n\t'Property Descriptor': function isPropertyDescriptor(ES, Desc) {\n\t\tif (ES.Type(Desc) !== 'Object') {\n\t\t\treturn false;\n\t\t}\n\t\tvar allowed = {\n\t\t\t'[[Configurable]]': true,\n\t\t\t'[[Enumerable]]': true,\n\t\t\t'[[Get]]': true,\n\t\t\t'[[Set]]': true,\n\t\t\t'[[Value]]': true,\n\t\t\t'[[Writable]]': true\n\t\t};\n\n\t\tfor (var key in Desc) { // eslint-disable-line\n\t\t\tif (has(Desc, key) && !allowed[key]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tvar isData = has(Desc, '[[Value]]');\n\t\tvar IsAccessor = has(Desc, '[[Get]]') || has(Desc, '[[Set]]');\n\t\tif (isData && IsAccessor) {\n\t\t\tthrow new $TypeError('Property Descriptors may not be both accessor and data descriptors');\n\t\t}\n\t\treturn true;\n\t}\n};\n\nmodule.exports = function assertRecord(ES, recordType, argumentName, value) {\n\tvar predicate = predicates[recordType];\n\tif (typeof predicate !== 'function') {\n\t\tthrow new $SyntaxError('unknown record type: ' + recordType);\n\t}\n\tif (!predicate(ES, value)) {\n\t\tthrow new $TypeError(argumentName + ' must be a ' + recordType);\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}