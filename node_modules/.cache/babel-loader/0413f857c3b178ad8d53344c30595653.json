{"ast":null,"code":"'use strict';\n\nvar trimStart = require('string.prototype.trimleft');\n\nvar trimEnd = require('string.prototype.trimright');\n\nvar inspect = require('object-inspect');\n\nvar ES2018 = require('./es2018');\n\nvar assign = require('./helpers/assign');\n\nvar MAX_SAFE_INTEGER = require('./helpers/maxSafeInteger');\n\nvar GetIntrinsic = require('./GetIntrinsic');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar ES2019 = assign(assign({}, ES2018), {\n  // https://tc39.es/ecma262/#sec-add-entries-from-iterable\n  AddEntriesFromIterable: function AddEntriesFromIterable(target, iterable, adder) {\n    if (!this.IsCallable(adder)) {\n      throw new $TypeError('Assertion failed: `adder` is not callable');\n    }\n\n    if (iterable == null) {\n      throw new $TypeError('Assertion failed: `iterable` is present, and not nullish');\n    }\n\n    var iteratorRecord = this.GetIterator(iterable);\n\n    while (true) {\n      // eslint-disable-line no-constant-condition\n      var next = this.IteratorStep(iteratorRecord);\n\n      if (!next) {\n        return target;\n      }\n\n      var nextItem = this.IteratorValue(next);\n\n      if (this.Type(nextItem) !== 'Object') {\n        var error = new $TypeError('iterator next must return an Object, got ' + inspect(nextItem));\n        return this.IteratorClose(iteratorRecord, function () {\n          throw error;\n        } // eslint-disable-line no-loop-func\n        );\n      }\n\n      try {\n        var k = this.Get(nextItem, '0');\n        var v = this.Get(nextItem, '1');\n        this.Call(adder, target, [k, v]);\n      } catch (e) {\n        return this.IteratorClose(iteratorRecord, function () {\n          throw e;\n        });\n      }\n    }\n  },\n  // https://ecma-international.org/ecma-262/10.0/#sec-flattenintoarray\n  // eslint-disable-next-line max-params, max-statements\n  FlattenIntoArray: function FlattenIntoArray(target, source, sourceLen, start, depth) {\n    var mapperFunction;\n\n    if (arguments.length > 5) {\n      mapperFunction = arguments[5];\n    }\n\n    var targetIndex = start;\n    var sourceIndex = 0;\n\n    while (sourceIndex < sourceLen) {\n      var P = this.ToString(sourceIndex);\n      var exists = this.HasProperty(source, P);\n\n      if (exists === true) {\n        var element = this.Get(source, P);\n\n        if (typeof mapperFunction !== 'undefined') {\n          if (arguments.length <= 6) {\n            throw new $TypeError('Assertion failed: thisArg is required when mapperFunction is provided');\n          }\n\n          element = this.Call(mapperFunction, arguments[6], [element, sourceIndex, source]);\n        }\n\n        var shouldFlatten = false;\n\n        if (depth > 0) {\n          shouldFlatten = this.IsArray(element);\n        }\n\n        if (shouldFlatten) {\n          var elementLen = this.ToLength(this.Get(element, 'length'));\n          targetIndex = this.FlattenIntoArray(target, element, elementLen, targetIndex, depth - 1);\n        } else {\n          if (targetIndex >= MAX_SAFE_INTEGER) {\n            throw new $TypeError('index too large');\n          }\n\n          this.CreateDataPropertyOrThrow(target, this.ToString(targetIndex), element);\n          targetIndex += 1;\n        }\n      }\n\n      sourceIndex += 1;\n    }\n\n    return targetIndex;\n  },\n  // https://ecma-international.org/ecma-262/10.0/#sec-trimstring\n  TrimString: function TrimString(string, where) {\n    var str = this.RequireObjectCoercible(string);\n    var S = this.ToString(str);\n    var T;\n\n    if (where === 'start') {\n      T = trimStart(S);\n    } else if (where === 'end') {\n      T = trimEnd(S);\n    } else if (where === 'start+end') {\n      T = trimStart(trimEnd(S));\n    } else {\n      throw new $TypeError('Assertion failed: invalid `where` value; must be \"start\", \"end\", or \"start+end\"');\n    }\n\n    return T;\n  }\n});\nmodule.exports = ES2019;","map":{"version":3,"sources":["C:/Users/gordon/Desktop/testRecrutement/node_modules/es-abstract/es2019.js"],"names":["trimStart","require","trimEnd","inspect","ES2018","assign","MAX_SAFE_INTEGER","GetIntrinsic","$TypeError","ES2019","AddEntriesFromIterable","target","iterable","adder","IsCallable","iteratorRecord","GetIterator","next","IteratorStep","nextItem","IteratorValue","Type","error","IteratorClose","k","Get","v","Call","e","FlattenIntoArray","source","sourceLen","start","depth","mapperFunction","arguments","length","targetIndex","sourceIndex","P","ToString","exists","HasProperty","element","shouldFlatten","IsArray","elementLen","ToLength","CreateDataPropertyOrThrow","TrimString","string","where","str","RequireObjectCoercible","S","T","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar trimStart = require('string.prototype.trimleft');\nvar trimEnd = require('string.prototype.trimright');\nvar inspect = require('object-inspect');\n\nvar ES2018 = require('./es2018');\nvar assign = require('./helpers/assign');\nvar MAX_SAFE_INTEGER = require('./helpers/maxSafeInteger');\n\nvar GetIntrinsic = require('./GetIntrinsic');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\n\nvar ES2019 = assign(assign({}, ES2018), {\n\t// https://tc39.es/ecma262/#sec-add-entries-from-iterable\n\tAddEntriesFromIterable: function AddEntriesFromIterable(target, iterable, adder) {\n\t\tif (!this.IsCallable(adder)) {\n\t\t\tthrow new $TypeError('Assertion failed: `adder` is not callable');\n\t\t}\n\t\tif (iterable == null) {\n\t\t\tthrow new $TypeError('Assertion failed: `iterable` is present, and not nullish');\n\t\t}\n\t\tvar iteratorRecord = this.GetIterator(iterable);\n\t\twhile (true) { // eslint-disable-line no-constant-condition\n\t\t\tvar next = this.IteratorStep(iteratorRecord);\n\t\t\tif (!next) {\n\t\t\t\treturn target;\n\t\t\t}\n\t\t\tvar nextItem = this.IteratorValue(next);\n\t\t\tif (this.Type(nextItem) !== 'Object') {\n\t\t\t\tvar error = new $TypeError('iterator next must return an Object, got ' + inspect(nextItem));\n\t\t\t\treturn this.IteratorClose(\n\t\t\t\t\titeratorRecord,\n\t\t\t\t\tfunction () { throw error; } // eslint-disable-line no-loop-func\n\t\t\t\t);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tvar k = this.Get(nextItem, '0');\n\t\t\t\tvar v = this.Get(nextItem, '1');\n\t\t\t\tthis.Call(adder, target, [k, v]);\n\t\t\t} catch (e) {\n\t\t\t\treturn this.IteratorClose(\n\t\t\t\t\titeratorRecord,\n\t\t\t\t\tfunction () { throw e; }\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t},\n\n\t// https://ecma-international.org/ecma-262/10.0/#sec-flattenintoarray\n\t// eslint-disable-next-line max-params, max-statements\n\tFlattenIntoArray: function FlattenIntoArray(target, source, sourceLen, start, depth) {\n\t\tvar mapperFunction;\n\t\tif (arguments.length > 5) {\n\t\t\tmapperFunction = arguments[5];\n\t\t}\n\n\t\tvar targetIndex = start;\n\t\tvar sourceIndex = 0;\n\t\twhile (sourceIndex < sourceLen) {\n\t\t\tvar P = this.ToString(sourceIndex);\n\t\t\tvar exists = this.HasProperty(source, P);\n\t\t\tif (exists === true) {\n\t\t\t\tvar element = this.Get(source, P);\n\t\t\t\tif (typeof mapperFunction !== 'undefined') {\n\t\t\t\t\tif (arguments.length <= 6) {\n\t\t\t\t\t\tthrow new $TypeError('Assertion failed: thisArg is required when mapperFunction is provided');\n\t\t\t\t\t}\n\t\t\t\t\telement = this.Call(mapperFunction, arguments[6], [element, sourceIndex, source]);\n\t\t\t\t}\n\t\t\t\tvar shouldFlatten = false;\n\t\t\t\tif (depth > 0) {\n\t\t\t\t\tshouldFlatten = this.IsArray(element);\n\t\t\t\t}\n\t\t\t\tif (shouldFlatten) {\n\t\t\t\t\tvar elementLen = this.ToLength(this.Get(element, 'length'));\n\t\t\t\t\ttargetIndex = this.FlattenIntoArray(target, element, elementLen, targetIndex, depth - 1);\n\t\t\t\t} else {\n\t\t\t\t\tif (targetIndex >= MAX_SAFE_INTEGER) {\n\t\t\t\t\t\tthrow new $TypeError('index too large');\n\t\t\t\t\t}\n\t\t\t\t\tthis.CreateDataPropertyOrThrow(target, this.ToString(targetIndex), element);\n\t\t\t\t\ttargetIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsourceIndex += 1;\n\t\t}\n\n\t\treturn targetIndex;\n\t},\n\n\t// https://ecma-international.org/ecma-262/10.0/#sec-trimstring\n\tTrimString: function TrimString(string, where) {\n\t\tvar str = this.RequireObjectCoercible(string);\n\t\tvar S = this.ToString(str);\n\t\tvar T;\n\t\tif (where === 'start') {\n\t\t\tT = trimStart(S);\n\t\t} else if (where === 'end') {\n\t\t\tT = trimEnd(S);\n\t\t} else if (where === 'start+end') {\n\t\t\tT = trimStart(trimEnd(S));\n\t\t} else {\n\t\t\tthrow new $TypeError('Assertion failed: invalid `where` value; must be \"start\", \"end\", or \"start+end\"');\n\t\t}\n\t\treturn T;\n\t}\n});\n\nmodule.exports = ES2019;\n"]},"metadata":{},"sourceType":"script"}